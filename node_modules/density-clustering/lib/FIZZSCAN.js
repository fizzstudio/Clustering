/**
 * DBSCAN - Density based clustering
 *
 * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>
 * @copyright MIT
 */

/**
 * FIZZSCAN class construcotr
 * @constructor
 *
 * @param {Array} dataset
 * @param {number} epsilon
 * @param {number} minPts
 * @param {function} distanceFunction
 * @returns {FIZZSCAN}
 */
function FIZZSCAN(dataset, epsilon, minPts, forceIn, distanceFunction) {
    /** @type {Array} */
    this.dataset = [];
    /** @type {number} */
    this.epsilon = 1;
    /** @type {number} */
    this.minPts = 2;
    /** @type {function} */
    this.distance = this._euclideanDistance;
    /** @type {boolean} */
    this.forceIn = false;
    /** @type {Array} */
    this.clusters = [];
    /** @type {Array} */
    this.clusterCentroids = [];
    /** @type {Array} */
    this.noise = [];
  
    // temporary variables used during computation
  
    /** @type {Array} */
    this._visited = [];
    /** @type {Array} */
    this._assigned = [];
    /** @type {number} */
    this._datasetLength = 0;
  
    this._init(dataset, epsilon, minPts, forceIn, distanceFunction);
  };
  
  /******************************************************************************/
  // public functions
  
  /**
   * Start clustering
   *
   * @param {Array} dataset
   * @param {number} epsilon
   * @param {number} minPts
   * @param {function} distanceFunction
   * @param {boolean} distanceFunction
   * @returns {undefined}
   * @access public
   */
  FIZZSCAN.prototype.run = function(dataset, epsilon, minPts, forceIn, distanceFunction) {
    this._init(dataset, epsilon, minPts, forceIn, distanceFunction);
  
    for (var pointId = 0; pointId < this._datasetLength; pointId++) {
      // if point is not visited, check if it forms a cluster
      if (this._visited[pointId] !== 1) {
        this._visited[pointId] = 1;
  
        // if closest neighborhood is too small to form a cluster, mark as noise
        var neighbors = this._regionQuery(pointId);
  
        if (neighbors.length < this.minPts) {
          this.noise.push(pointId);
        } else {
          // create new cluster and add point
          var clusterId = this.clusters.length;
          this.clusters.push([]);
          this._addToCluster(pointId, clusterId);
  
          this._expandCluster(clusterId, neighbors);
        }
      }
    }
    //console.log(this.clusters);
    //console.log(this.noise);
    //console.log("before declustering");
    
    //Declusters extremely small clusters in large datasets into noise.

    //Current behavior forces the small cluster points into the last indexed large cluster instead of noise for some reason.
    //The above statements will log the clusters as already having been modified before the below code block runs, also for some reason.


   
    if (this.dataset.length > 1000){
      var t = this.minPts*2;
      for (var clusterId = 0; clusterId < this.clusters.length; clusterId++){
        var tempCluster = this.clusters[clusterId];
        if (tempCluster.length < t){
          for (var pointId = 0; pointId< tempCluster.length; pointId++){
            this.noise.push(tempCluster[pointId])
          }
          this.clusters[clusterId] = null;
        }
      }
      //console.log(this.clusters);
      //console.log("before filtering");
      this.clusters = this.clusters.filter((e) => e !== null)
    }
    //console.log(this.clusters);
    //console.log(this.noise);
    //console.log("before forcing");
/*
    //Optionally forces clustering of noise/outlier points by distance to nearest centroid
    if (this.forceIn){
      for (var i = 0; i< this.clusters.length; i++){
        //console.log(this.clusters[i]);
        //console.log(this._centroid(this.clusters[i]))
        this.clusterCentroids.push(this._centroid(this.clusters[i]));
      }
      //console.log(this.clusterCentroids, this.noise);
      for (var pointId = 0; pointId < this.noise.length; pointId++) {
        let dist = 0;
        let nearestClusterId = 0;
        for (var clusterId = 0; clusterId < this.clusterCentroids.length; clusterId++) {
          let testDist = this.distance(dataset[pointId], this.clusterCentroids[clusterId])
          if (dist == 0){
            dist = testDist;
            nearestClusterId = clusterId;
          }
          else{
            if (dist > testDist){
              //console.log("hit")
              //console.log(testDist)
              //console.log(clusterId)
              dist = testDist;
              nearestClusterId = clusterId;
            }
          }
        }
        console.log(this.noise[pointId]);
        this._addToCluster(this.dataset.indexOf(this.dataset[this.noise[pointId]]),nearestClusterId);
      }
      this.noise = [];
    }
*/
if (this.forceIn){
  for (var i = 0; i< this.clusters.length; i++){
    //console.log(this.clusters[i]);
    //console.log(this._centroid(this.clusters[i]))
    this.clusterCentroids.push(this._centroid(this.clusters[i]));
  }
  //console.log(this.clusterCentroids, this.noise);
  for (var noisePointID of this.noise) {
    let dist = 0;
    let nearestClusterId = 0;
    for (var clusterId = 0; clusterId < this.clusterCentroids.length; clusterId++) {
      let testDist = this.distance(dataset[noisePointID], this.clusterCentroids[clusterId])
      if (dist == 0){
        dist = testDist;
        nearestClusterId = clusterId;
      }
      else{
        if (dist > testDist){
          //console.log("hit")
          //console.log(testDist)
          //console.log(clusterId)
          dist = testDist;
          nearestClusterId = clusterId;
        }
      }
    }
    console.log(noisePointID);
    this._addToCluster(noisePointID, nearestClusterId);
  }
  this.noise = [];
}






    return this.clusters;
  };
  
  /******************************************************************************/
  // protected functions
  
  /**
   * Set object properties
   *
   * @param {Array} dataset
   * @param {number} epsilon
   * @param {number} minPts
   * @param {function} distance
   * @param {boolean} forceIn
   * @returns {undefined}
   * @access protected
   */
  FIZZSCAN.prototype._init = function(dataset, epsilon, minPts, forceIn, distance) {
  
    if (dataset) {
  
      if (!(dataset instanceof Array)) {
        throw Error('Dataset must be of type array, ' +
          typeof dataset + ' given');
      }
  
      this.dataset = dataset;
      this.clusters = [];
      this.noise = [];
  
      this._datasetLength = dataset.length;
      this._visited = new Array(this._datasetLength);
      this._assigned = new Array(this._datasetLength);
    }
  
    if (epsilon) {
      this.epsilon = epsilon;
    }
  
    if (minPts) {
      this.minPts = minPts;
    }
  
    if (distance) {
      this.distance = distance;
    }

    if (forceIn) {
      this.forceIn = forceIn;
    }
  };
  
  /**
   * Expand cluster to closest points of given neighborhood
   *
   * @param {number} clusterId
   * @param {Array} neighbors
   * @returns {undefined}
   * @access protected
   */
  FIZZSCAN.prototype._expandCluster = function(clusterId, neighbors) {
  
    /**
     * It's very important to calculate length of neighbors array each time,
     * as the number of elements changes over time
     */
    for (var i = 0; i < neighbors.length; i++) {
      var pointId2 = neighbors[i];
  
      if (this._visited[pointId2] !== 1) {
        this._visited[pointId2] = 1;
        var neighbors2 = this._regionQuery(pointId2);
  
        if (neighbors2.length >= this.minPts) {
          neighbors = this._mergeArrays(neighbors, neighbors2);
        }
      }
  
      // add to cluster
      if (this._assigned[pointId2] !== 1) {
        this._addToCluster(pointId2, clusterId);
      }
    }
  };
  
  /**
   * Add new point to cluster
   *
   * @param {number} pointId
   * @param {number} clusterId
   */
  FIZZSCAN.prototype._addToCluster = function(pointId, clusterId) {
    this.clusters[clusterId].push(pointId);
    this._assigned[pointId] = 1;
  };
  
  /**
   * Find all neighbors around given point
   *
   * @param {number} pointId,
   * @param {number} epsilon
   * @returns {Array}
   * @access protected
   */
  FIZZSCAN.prototype._regionQuery = function(pointId) {
    var neighbors = [];
  
    for (var id = 0; id < this._datasetLength; id++) {
      var dist = this.distance(this.dataset[pointId], this.dataset[id]);
      if (dist < this.epsilon) {
        neighbors.push(id);
      }
    }
  
    return neighbors;
  };
  
  /******************************************************************************/
  // helpers
  
  /**
   * @param {Array} a
   * @param {Array} b
   * @returns {Array}
   * @access protected
   */
  FIZZSCAN.prototype._mergeArrays = function(a, b) {
    var len = b.length;
  
    for (var i = 0; i < len; i++) {
      var P = b[i];
      if (a.indexOf(P) < 0) {
        a.push(P);
      }
    }
  
    return a;
  };
  
  /**
   * Calculate euclidean distance in multidimensional space
   *
   * @param {Array} p
   * @param {Array} q
   * @returns {number}
   * @access protected
   */
  FIZZSCAN.prototype._euclideanDistance = function(p, q) {
    var sum = 0;
    var i = Math.min(p.length, q.length);
  
    while (i--) {
      sum += (p[i] - q[i]) * (p[i] - q[i]);
    }
  
    return Math.sqrt(sum);
  };
  
  /**
   * Calculate centroid of a group of points
   *
   * @param {Array} c
   * @returns {Array}
   * @access protected
   */
  FIZZSCAN.prototype._centroid = function(c) {
    var centroid = [];
    var i = 0;
    var j = 0;
    var l = c.length;
    var points = [];
    for (i = 0; i< l; i++){
      points.push(this.dataset[c[i]])
    }
    for (i = 0; i< l; i++){
        for (j = 0; j< points[i].length; j++){
            if (centroid[j] !== undefined){
                centroid[j] += points[i][j]/l;
            }
            else{
                centroid.push(0);
                centroid[j] += points[i][j]/l;
            }
        }
    }
    return centroid;
  }


  if (typeof module !== 'undefined' && module.exports) {
    module.exports = FIZZSCAN;
  }